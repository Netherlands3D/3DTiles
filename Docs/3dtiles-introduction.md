# 3D Tiles Introduction: Explicit & Implicit Tiling, Quadtrees, and Morton Index

This page provides a conceptual overview of the 3D Tiles format, including explicit and implicit tiling, quadtree structures, and the Morton (Z-order) index for spatial subdivision.

## What is 3D Tiles?
3D Tiles is an open specification for streaming and rendering massive heterogeneous 3D geospatial datasets. It is used for city models, photogrammetry, point clouds, and more. Tiles are organized in a spatial hierarchy, allowing efficient loading and rendering based on view and level of detail (LOD).

# Explicit Tiling
In explicit tiling, every tile and its children are explicitly listed in the tileset JSON. Each tile contains a list of its children, their bounding volumes, geometric errors, and content URIs. This approach is straightforward and flexible, but can result in very large tileset files for deep or wide hierarchies.

**Example (explicit):**
```json
{
  "root": {
    "boundingVolume": { "region": [...] },
    "geometricError": 500,
    "refine": "REPLACE",
    "children": [
      {
        "boundingVolume": { "region": [...] },
        "geometricError": 250,
        "content": { "uri": "tile1.glb" },
        "children": [ ... ]
      },
      ...
    ]
  }
}
```

# Implicit Tiling
Implicit tiling is a technique in 3D Tiles that allows you to define a regular, deeply nested tile structure (like a quadtree or octree) without explicitly listing every tile in the tileset JSON. Instead, a set of rules and templates define how tiles are subdivided and addressed.

- **Root tile**: Covers the entire region of interest (e.g., the world or a city).
- **Subdivision**: Each tile is subdivided into 4 (quadtree, 2D) or 8 (octree, 3D) child tiles.
- **Levels**: Each subdivision increases the level (LOD) by 1, halving the tile size in each dimension.
- **BoundingVolume**: Each tile has a bounding volume (region, box, or sphere) that defines its spatial extent.

**Example (implicit):**
```json
{
  "root": {
    "boundingVolume": { "region": [minLon, minLat, maxLon, maxLat, minHeight, maxHeight] },
    "geometricError": 500,
    "refine": "REPLACE",
    "implicitTiling": {
      "subdivisionScheme": "QUADTREE",
      "availableLevels": 14,
      "subtreeLevels": 3,
      "subtrees": { "uri": "subtrees/{level}/{x}/{y}.subtree" }
    },
    "content": { "uri": "content/{level}/{x}/{y}.glb" }
  }
}
```

# Explicit vs. Implicit Tiling
| Feature                | Explicit Tiling                        | Implicit Tiling                         |
|------------------------|----------------------------------------|-----------------------------------------|
| Tile listing           | All tiles listed in JSON               | Tiles generated by rules/templates       |
| File size              | Can be very large for big hierarchies  | Compact, even for deep trees            |
| Flexibility            | Arbitrary hierarchies possible         | Regular (quadtree/octree) only          |
| Addressing             | By tree traversal                      | By (level, x, y) or Morton index        |
| Use case               | Small/medium, irregular datasets       | Large, regular, grid-like datasets      |

In summary: **Explicit tiling** is best for small or irregular datasets where you need full control over the hierarchy. **Implicit tiling** is ideal for massive, regular datasets (like terrain, photogrammetry, or city meshes) where a grid structure is sufficient and scalability is critical.


# Understanding Geometric Error & SSE (Screen Space Error)

Each tile has a **geometric error** — a value in meters that indicates how much detail this tile still visually represents well at a given viewing distance.

With **implicit tiling**, these values usually follow fixed steps (e.g., halving per level), while with **explicit tiling** they can be freely set per tile in the `tileset.json`.

You can think of it as:

> "Up to approximately this distance, this tile still looks good enough; closer up you need more detail (the child tile)."

The **Screen Space Error (SSE)** shows in pixels how much the tile deviates from reality on your screen. A higher SSE means the tile deviates too much from reality and more detail is needed. SSE is calculated using the formula:

```
                    geometricError × (viewportHeight/(2 × tan(fov/2)))
            SSE = ───────────────────────────────────────────────────────
                                        distance
```

where:
- **geometricError** → value in meters; larger value means larger tile
- **viewportHeight** → screen height in pixels  
- **fov** → camera field of view
- **distance** → distance from camera to the closest point of the tile's bounding volume

### SSE Threshold

In practice, the viewer or engine uses an SSE threshold (e.g., 16 pixels) to determine when a tile should be refined.

**SSE > threshold** → tile gets refined (load more detail)

**SSE ≤ threshold** → tile stays as it is

This keeps the display visually consistent, without loading unnecessarily much detail.

## What this means in practice (example with a large tile)

| Situation | SSE | Action |
|-----------|-----|---------|
| Tile is close (small distance) | High | Tile looks too coarse → refine (load child tile with more detail) |
| Tile is far away (large distance) | Low | Tile looks sharp enough → keep current tile |



# Tile Refinement: REPLACE vs ADD

3D Tiles supports two refinement strategies that control how parent and child tiles are rendered together:

## REPLACE Refinement (Most Common)

**How it works**: Child tiles **replace** their parent tile when loading higher detail.

```json
{
  "refine": "REPLACE",
  "geometricError": 100,
  "children": [...]
}
```

**Rendering behavior**:
- When camera is far away: Show only parent tile
- When camera gets closer: Hide parent, show child tiles instead
- **Never show parent and children simultaneously**

**Use cases**:
- **Building models**: Parent shows simple box, children show detailed architecture
- **Terrain**: Parent shows low-poly terrain, children show high-poly details
- **Google Reality Mesh**: Uses REPLACE for progressive detail levels

**Code impact** in `LoadInViewRecursively()`:
```csharp
if (enoughDetail || tile.ChildrenCount == 0) {
    // Load this tile - we have enough detail OR it's a leaf
} else {
    // Not enough detail - traverse deeper to children
    // Don't load parent tile for REPLACE refinement
}
```

## ADD Refinement (Additive)

**How it works**: Child tiles are **added on top of** their parent tile.

```json
{
  "refine": "ADD", 
  "geometricError": 100,
  "children": [...]
}
```

**Rendering behavior**:
- Parent tile remains visible
- Child tiles are rendered **in addition to** the parent
- **Both parent and children are shown together**

**Use cases**:
- **Terrain with objects**: Parent shows terrain, children add trees/buildings on top
- **Base layer + details**: Parent shows foundation, children add architectural details
- **Layered datasets**: Different detail layers that complement each other

**Code impact** in `LoadInViewRecursively()`:
```csharp
else {
    // Not enough detail and we have children - traverse deeper first
    foreach (var childTile in tile.children) {
        LoadInViewRecursively(childTile, currentCamera);
    }
    
    // Special case: if it's ADD refinement, also show parent alongside children
    if (tile.refine == "ADD" && Has3DContent) {
        RequestContentUpdate(tile); // Load parent too!
    }
}
```

## Visual Comparison

**REPLACE Example**:
```
Camera far away:  [Parent Building]
Camera closer:    [Detailed Wall 1] [Detailed Wall 2] [Detailed Roof]
                  (Parent hidden)
```

**ADD Example**:
```
Camera far away:  [Terrain Base]
Camera closer:    [Terrain Base] + [Tree 1] + [Tree 2] + [Building]
                  (Parent remains visible)
```

## Performance Considerations

- **REPLACE**: More memory efficient (only one level loaded at a time)
- **ADD**: Higher memory usage (multiple levels loaded simultaneously)
- **REPLACE**: Better for mobile/WebGL with memory constraints
- **ADD**: Better for rich, layered scenes where context matters


# Quadtree Structure
A quadtree recursively subdivides a 2D area into four quadrants:

```
Level 0: [root]
Level 1: [0,0], [0,1], [1,0], [1,1]
Level 2: [0,0], [0,1], [1,0], [1,1] for each parent, etc.
```

- At each level, the number of tiles = 4^level.
- Each tile can be uniquely identified by its (level, x, y) coordinates.

# Morton Index (Z-order Curve)
The Morton index (or Z-order curve) is a way to map 2D (or 3D) tile coordinates to a single integer, preserving spatial locality. It is often used for efficient tile addressing and storage.

- **Interleaving bits**: For (x, y), the Morton code is created by interleaving the bits of x and y.
- **Example**: x=2 (10b), y=3 (11b) → Morton code = 1101b = 13

This allows fast lookup and traversal of tiles in memory or on disk.

# References
- [3D Tiles Specification](https://github.com/CesiumGS/3d-tiles/tree/main/specification)
- [Implicit Tiling Spec](https://github.com/CesiumGS/3d-tiles/tree/main/specification/ImplicitTiling)
- [Morton Code (Wikipedia)](https://en.wikipedia.org/wiki/Z-order_curve)
- [Cesium Selection Algorithm Details](https://cesium.com/learn/cesium-native/ref-doc/selection-algorithm-details.html)

---

*This page is a living document and can be expanded as the project evolves.*

## Abbreviations & terms

- SSE — Screen Space Error. A metric used to decide whether a tile's geometric error is acceptable given its projected size on screen. Lower SSE means higher perceived detail; SSE is typically compared to a threshold to determine whether to refine (load children) or use the parent tile.
- LOD — Level of Detail. Refers to the depth/level in the tile hierarchy; higher LODs are more detailed (smaller tiles).
- GLB — Binary GLTF. A single-file binary GLTF asset that contains geometry, textures and materials; commonly used as content payloads for 3D Tiles.
- ECEF — Earth-Centered, Earth-Fixed. A Cartesian coordinate system centered at the Earth's center; often used for global geospatial positioning.
- SSE component / sseComponent — A camera- and screen-dependent scalar used when calculating screen-space error (often derived from screen height and camera FOV). Multiplying geometricError by this component produces a screen-space scaled error.
- REPLACE / ADD — Refinement modes for tiles: REPLACE means a parent tile replaces its children when rendered; ADD means parent and children are rendered together (additive refinement).

